# 객체 선언
- 코틀린은 어떤 클래스에 인스턴스가 오직 하나만 존재하게 보장하는 싱글턴 패턴을 내장
- 클래스와 비슷한 방법으로 싱글턴을 선언
  - class 대신 object라는 키워드를 사용

```kt
object Application {
  val name = "My Application"
  override fun toString() = name
  fun exit() { }
}
```
이런 객체 선언은 클래스를 정의하는 동시에 클래스의 인스턴스를 정의하는 것이기도 하다. 예를 들어 다음 코드를 보자.

```kt
fun describe(app: Application) = app.name // Application은 타입임

fun main() {
  println(Application)                    // Application은 값임
}
```
일반적으로 객체의 인스턴스는 단 하나뿐이므로 인스턴스만 가리켜도 어떤 타입을 쓰는지 충분히 알 수 있다. 따라서 객체를 타입으로 사용해도 무의미하다.

객체 정의는 스레드 안전하다. 컴파일러는 실행되는 여러 스레드에서 싱글턴에 접근하더라도 오직 한 인스턴스만 공유되고 초기화 코드도 단 한 번만 실행되도록 보장한다.



- 코틀린 코드에서는 INSTANCE 변수에 접근할 수 없다. 하지만 코틀린의 싱글턴을 참조하는 자바 클래스에서는 이 변수를 사용할 수 있다.
- 객체 선언도 멤버 함수와 프로퍼티를 포함할 수 있다.
- 초기화 블록도 포함할 수 있다. 
- 객체에는 주생성자나 부생성자가 없다.
- 객체 인스턴스는 항상 암시적으로 만들어지기 때문에 객체의 경우 생성자 호출이 아무런 의미가 없다.

- 객체의 본문에 들어있는 클래스에는 inner가 붙을 수 없다.
  - 내부 클래스의 인스턴스는 항상 바깥쪽 클래스의 인스턴스와 연관되는데, 객체 선언은 항상 인스턴스가 하나뿐이므로 inner 변경자가 불필요해진다. 그래서 객체 안에 정의된 클래스에 대해서는 inner 사용을 금지


> https://thebook.io/080250/0169/

